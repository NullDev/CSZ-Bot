import { Util } from "discord.js";
import moment from "moment";

import { getConfig } from "../utils/configHandler";
const config = getConfig();

// Truly random seed, generated by putting trainee in front of vim and tell him to exit
const randomSeed = "AQa0B7HK4vvrBOlaKKplMsKorGhN4gJvOCBWxw531P8uwpeIU3d39ODZ02fbvcxiImOwAOuOtR4eaiPDkyTCbSqzKnaJWqp4AqwxOTMgU2UCPWKIH4WXCQzVq8M7oqWBF32KEAdAoXvAm5o3Wvl4MOwdMJk1LleFjv7mQJizltVw3Y2Tan88uc3JxoJurDTKvxBzRt6H";

// Just for reference, this is how it's supposed to be done:
// const randomSeed = String(require("crypto").randomBytes(200));
// gg @tobi6112

/**
 * Index of Coincedence
 *
 * @param {string} s
 * @returns {number} index
 */
const iocCalculator = function(s){
    let bigrams = new Map();
    let text = s.replace(/\s+/g, "");
    [...text].forEach(c => (bigrams.has(c) ? bigrams.set(c, bigrams.get(c) + 1) : bigrams.set(c, 1)));

    let sum = 0;
    bigrams.forEach(v => (sum += v + (v - 1)));
    return sum / (text.length * (text.length - 1));
};

/**
 * Highly complex and very very secure
 *
 * @param {number} min
 * @param {number} max
 * @param {number} seed
 * @returns {number} random floored number >= min and <= max
 */
const rng = function(min, max, seed){
    let sido = (seed * 9301 + 49297) % 233280;
    let rnd = sido / 233280;
    let disp = Math.abs(Math.sin(sido));

    rnd = rnd + disp - Math.floor(rnd + disp);

    return Math.floor((min || 0) + rnd * ((max || 1) - (min || 0) + 1));
};

const ioc = iocCalculator(randomSeed);

/**
 * Highly complex, secure and optimized decision maker algorithm
 *
 * @param {string} question
 * @param {number} max
 * @returns {number} decision
 */
const secureDecisionMaker = (question, max = 1) => (rng(0, max, (Date.now() * ioc) / iocCalculator(question)));

/**
 * Creates a new secure decision (sdm; yes/no)
 *
 * @param {import("discord.js").Client} client
 * @param {import("discord.js").Message} message
 * @param {Array<unknown>} args
 * @returns {Promise<string | void>}
 */
export const run = async(client, message, args) => {
    if (!args.length) return "Bruder da ist keine Frage :c";

    let question = args.join(" ").replace(/\s\s+/g, " ");
    const options = question.split(/,|;|\s+oder\s+/gi).map(s => s.trim()).filter(s => !!s);

    if(options.length > 1) {
        question = options.reduce((p, c, i, a) => (`${p}${i === a.length - 1 ? " oder " : ", "}${c}`));
    }
    if (!question.endsWith("?")) question += "?";

    const embed = {
        title: Util.cleanContent(question, message),
        timestamp: moment.utc().format(),
        author: {
            name: `Secure Decision f√ºr ${message.author.username}`,
            icon_url: message.author.displayAvatarURL()
        }
    };

    if(options.length === 1) {
        const decision = secureDecisionMaker(question);
        let file;
        if(!!decision) {
            embed.color = 0x2ecc71;
            file = "yes.png";
        }
        else {
            embed.color = 0xe74c3c;
            file = "no.png";
        }
        embed.thumbnail = {
            url: `attachment://${file}`
        };

        await message.channel.send({
            embeds: [embed],
            files: [`./assets/${file}`]
        });
    }
    else {
        const decision = secureDecisionMaker(question, options.length - 1);
        embed.color = 0x9b59b6;
        embed.description = `Mashallah, ich rate dir zu **${options[decision]}**!`;

        await message.channel.send({
            embeds: [embed]
        });
    }
    await message.delete();
};

export const description = `Macht eine Secure Decision mithilfe eines komplexen, hochoptimierten, Blockchain Algorithmus.\nUsage:\n**ja/nein Frage**\n ${config.bot_settings.prefix.command_prefix}sdm [Hier die Frage]\n\n**Secure Auswahl**\n\n${config.bot_settings.prefix.command_prefix}sdm [Auswahl 1]; [Auswahl 2]`;
